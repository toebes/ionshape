package main

import (
	"fmt"
	"strconv"

	"github.com/toebes/go-client/onshape"
)

// ColorDataProperties maps a color structure into something more managable
type ColorDataProperties struct {
	colorRed    int
	colorGreen  int
	colorBlue   int
	opacity     float64
	isGenerated bool
	color       string
}

// MapColorData maps a generic interface into the appropriate color data
// This code really should sanity check the map a bit more..
//  	{
//  	 	"isGenerated" : true,
//		 	"color" : {
//   			"red" : 157,
//	   			"green" : 207,
//  	 		"blue" : 237
// 			},
//	 		"opacity" : 255
// 		}
func MapColorData(data map[string]interface{}) (ColorDataProperties, error) {
	result := ColorDataProperties{colorRed: 0.0, colorGreen: 0.0, colorBlue: 0.0, opacity: 1.0, isGenerated: true}
	isGenerated, found := data["isGenerated"]
	if found {
		result.isGenerated = isGenerated.(bool)
	}
	opacity, found := data["opacity"]
	if found {
		result.opacity = opacity.(float64) / 255.0
	}
	color, found := data["color"]
	if found {
		colorMap := color.(map[string]interface{})
		red, found := colorMap["red"]
		if found {
			result.colorRed = int(red.(float64))
		}
		green, found := colorMap["green"]
		if found {
			result.colorRed = int(green.(float64))
		}
		blue, found := colorMap["blue"]
		if found {
			result.colorRed = int(blue.(float64))
		}
	}
	result.color = fmt.Sprintf("#%02x%02x%02x", result.colorRed, result.colorGreen, result.colorBlue)
	if result.opacity != 1.0 {
		result.color += fmt.Sprintf(" Opacity:%.2f", result.opacity)
	}
	if result.isGenerated {
		result.color += " AutoGenerated"
	}
	return result, nil
}

// ConsolidatedProperties is an aggregation of the metadata for an object
type ConsolidatedProperties struct {
	Name               string
	Description        string
	SKU                string
	Vendor             string
	ExcludeFromBOM     bool
	NotRevisionManaged bool
	State              string
	UnitOfMeasure      string
	DrawnBy            string
	DateLastChanged    onshape.JSONTime
	DateDrawn          onshape.JSONTime
	LastChangedBy      string
	Extras             string
	Color              string
}

// GetConsolidatedProperties navigates a Metadata array and consolidates the important information into a single structure.
func GetConsolidatedProperties(metadata []onshape.BTMetadataItemsProperties) (ConsolidatedProperties, error) {
	var result = ConsolidatedProperties{}
	var err error = nil
	var extra = ""
	// Iterate over all the elements in the document.
	for _, metadataItem := range metadata {
		// This is where we have a bit of challenge with the API.  We have to determine the type
		// of the property in order to access the correct polymorhpic structure of data
		metadataType := metadataItem.BTMetadataItemsPropertiesInterface.GetValueType()
		extradata := ""
		switch metadataType {
		case "BOOL":
			propIface := metadataItem.BTMetadataItemsPropertiesInterface.(*onshape.BTMetadataCommonBool)
			name, hasName := propIface.GetNameOk()
			pval, hasPval := propIface.GetValueOk()
			if hasName && hasPval {
				switch *name {
				case "Exclude from BOM":
					result.ExcludeFromBOM = *pval
				case "Not revision managed":
					result.NotRevisionManaged = *pval
				default:
					extradata = "BOOL:" + *name + "=" + strconv.FormatBool(*pval)

				}
			}

		case "CATEGORY":
			propIface := metadataItem.BTMetadataItemsPropertiesInterface.(*onshape.BTMetadataCommonCategory)
			name, hasName := propIface.GetNameOk()
			_ /*pval*/, hasPval := propIface.GetValueOk()
			if hasName && hasPval {
				extradata = "CATEGORY:" + *name

			}
		case "COMPUTED":

		case "DATE":
			propIface := metadataItem.BTMetadataItemsPropertiesInterface.(*onshape.BTMetadataCommonDate)
			name, hasName := propIface.GetNameOk()
			pval, hasPval := propIface.GetValueOk()
			if hasName && hasPval {
				switch *name {
				case "Last changed date":
					result.DateLastChanged = *pval
				case "Date drawn":
					result.DateDrawn = *pval
				default:
					extradata = *name + "=" + (*pval).Format("Mon Jan _2 15:04:05 2006")
				}

			}
		case "ENUM":
			propIface := metadataItem.BTMetadataItemsPropertiesInterface.(*onshape.BTMetadataCommonEnum)
			name, hasName := propIface.GetNameOk()
			pval, hasPval := propIface.GetValueOk()
			if hasName && hasPval {
				switch *name {
				case "State":
					result.State = *pval
				case "Unit of measure":
					result.UnitOfMeasure = *pval
				case "Tessellation quality":
					// We will skip it.
				default:
					extradata = "ENUM:" + *name + "=" + *pval
				}
			}
		case "OBJECT":
			propIface := metadataItem.BTMetadataItemsPropertiesInterface.(*onshape.BTMetadataCommonObject)
			name, hasName := propIface.GetNameOk()
			pval, hasPval := propIface.GetValueOk()
			if hasName && hasPval {
				switch *name {
				case "Appearance":
					colordata, err := MapColorData(*pval)
					if err != nil {
						return result, err
					}
					extradata = fmt.Sprintf("%v=%v", *name, colordata.color)
				default:
					///
					// Material=map[displayName:Hardened Alloy Steel
					// id:Hardened Alloy Steel
					// libraryName:Onshape Material Library
					// libraryReference:map[documentId:2718281828459eacfeeda11f
					// 					 elementId:6bbab304a1f64e7d640a2d7d
					// 					 elementMicroversionId:73414798ff906ef5dcd28cf3
					// 					 versionId:b5704e766ea5b04d206aee1a]
					// properties:[map[category:Physical
					// 				description:Density
					// 				displayName:Density
					// 				name:DENS
					// 				type:REAL
					// 				units:kg/m^3
					// 				value:7850]]
					///
					extradata = fmt.Sprintf("OBJECT:%v=%v", *name, *pval)
				}
			}
		case "STRING":
			propIface := metadataItem.BTMetadataItemsPropertiesInterface.(*onshape.BTMetadataCommonString)
			name, hasName := propIface.GetNameOk()
			pval, hasPval := propIface.GetValueOk()
			if hasName && hasPval {
				switch *name {
				case "Name":
					result.Name = *pval
				case "Description":
					result.Description = *pval
				case "Part number":
					result.SKU = *pval
				case "Vendor":
					result.Vendor = *pval
				default:
					extradata = "STRING:" + *name + "=" + *pval
				}
			}
		case "USER":
			propIface := metadataItem.BTMetadataItemsPropertiesInterface.(*onshape.BTMetadataCommonUser)
			name, hasName := propIface.GetNameOk()
			pval, hasPval := propIface.GetValueOk()
			if hasName && hasPval && len(*pval) > 0 {
				userName, hasUserName := ((*pval)[0]).GetNameOk()
				if hasUserName {
					switch *name {
					case "Last changed by":
						result.LastChangedBy = *userName
					case "Drawn by":
						result.DrawnBy = *userName
					default:
						extradata = *name + "=" + *userName
					}
				}
			}
		default:
			extradata = "UNHANDLED METADATATYPE:" + metadataType
		}
		if extradata != "" {
			result.Extras += extra + extradata
			extra = ", "
		}
	}
	return result, err
}
